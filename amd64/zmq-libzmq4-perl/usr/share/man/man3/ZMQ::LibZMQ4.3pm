.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ZMQ::LibZMQ4 3pm"
.TH ZMQ::LibZMQ4 3pm "2014-09-19" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ZMQ::LibZMQ4 \- A libzmq 4.x wrapper for Perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use ZMQ::LibZMQ4;
\&    use ZMQ::Constants; # separate module
\&
\&    my $ctxt = zmq_init($threads);
\&    my $rv   = zmq_term($ctxt);
\&
\&    my $msg  = zmq_msg_init();
\&    my $msg  = zmq_msg_init_size( $size );
\&    my $msg  = zmq_msg_init_data( $data );
\&    my $rv   = zmq_msg_close( $msg );
\&    my $rv   = zmq_msg_move( $dest, $src );
\&    my $rv   = zmq_msg_copy( $dest, $src );
\&    my $data = zmq_msg_data( $msg );
\&    my $size = zmq_msg_size( $msg);
\&
\&    my $sock = zmq_socket( $ctxt, $type );
\&    my $rv   = zmq_close( $sock );
\&    my $rv   = zmq_setsockopt( $socket, $option, $value );
\&    my $val  = zmq_getsockopt( $socket, $option );
\&    my $rv   = zmq_bind( $sock, $addr );
\&    my $rv   = zmq_send( $sock, $buffer, $length, $flags );
\&    my $msg  = zmq_sendmsg( $sock, $msg, $flags );
\&    my $rv   = zmq_recv( $sock, $buffer, $length, $flags );
\&    my $msg  = zmq_recvmsg( $sock, $flags );
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
If you have libzmq registered with pkg-config:
.PP
.Vb 4
\&    perl Makefile.PL
\&    make 
\&    make test
\&    make install
.Ve
.PP
If you don't have pkg-config, and libzmq is installed under /usr/local/libzmq:
.PP
.Vb 5
\&    ZMQ_HOME=/usr/local/libzmq \e
\&        perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you want to customize include directories and such:
.PP
.Vb 7
\&    ZMQ_INCLUDES=/path/to/libzmq/include \e
\&    ZMQ_LIBS=/path/to/libzmq/lib \e
\&    ZMQ_H=/path/to/libzmq/include/zmq.h \e
\&        perl Makefile.PL
\&    make
\&    make test
\&    make install
.Ve
.PP
If you want to compile with debugging on:
.PP
.Vb 1
\&    perl Makefile.PL \-g
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`ZMQ::LibZMQ4\*(C'\fR module is a wrapper of the 0MQ message passing library for Perl.
.PP
Before you start using this module, please make sure you have read and understood the zguide.
.PP
.Vb 1
\&    http://zguide.zeromq.org/page:all
.Ve
.PP
For specifics on each function, please refer to their documentation for the definitive explanation of each.
.PP
.Vb 1
\&    http://api.zeromq.org/
.Ve
.PP
This module is merely a thin wrapper around the C \s-1API:\s0 You need to understand
how the C \s-1API\s0 works in order to properly use this module.
.PP
Note that this is a wrapper for libzmq 4.x. For 2.x, you need to check ZMQ::LibZMQ2 and for 3.x, you need to check ZMQ::LibZMQ3
.SH "BASIC USAGE"
.IX Header "BASIC USAGE"
Please make sure you already have ZMQ::Constants module. If you installed
ZMQ::LibZMQ4 from \s-1CPAN\s0 via cpan/cpanm, it should have already been installed
for you. All socket types and other flags are declared in this module.
.PP
To start using ZMQ::LibZMQ4, you need to create a context object, then as many ZMQ::LibZMQ4::Socket objects as you need:
.PP
.Vb 2
\&    my $ctxt = zmq_init;
\&    my $socket = zmq_socket( $ctxt, ... options );
.Ve
.PP
You need to call \f(CW\*(C`zmq_bind()\*(C'\fR or \f(CW\*(C`zmq_connect()\*(C'\fR on the socket, depending on your usage. For example on a typical server-client model you would write on the server side:
.PP
.Vb 1
\&    zmq_bind( $socket, "tcp://127.0.0.1:9999" );
.Ve
.PP
and on the client side:
.PP
.Vb 1
\&    zmq_connect( $socket, "tcp://127.0.0.1:9999" );
.Ve
.PP
The underlying zeromq library offers \s-1TCP,\s0 multicast, in-process, and ipc connection patterns. Read the zeromq manual for more details on other ways to setup the socket.
.PP
When sending data, you can either pass a ZMQ::LibZMQ4::Message object or a
Perl string.
.PP
.Vb 3
\&    # the following two send() calls are equivalent
\&    my $msg = zmq_msg_init_data( "a simple message" );
\&    zmq_sendmsg( $socket, $msg );
\&    
\&    zmq_sendmsg( $socket, "a simple message" );
.Ve
.PP
In most cases using ZMQ::LibZMQ4::Message is redundant, so you will most
likely use the string version.
.PP
To receive, simply call \f(CW\*(C`zmq_recvmsg()\*(C'\fR on the socket
.PP
.Vb 1
\&    my $msg = zmq_recvmsg( $socket );
.Ve
.PP
The received message is an instance of ZMQ::LibZMQ4::Message object, and you can access the content held in the message via the \f(CW\*(C`zmq_msg_data()\*(C'\fR method:
.PP
.Vb 1
\&    my $data = zmq_msg_data( $msg );
.Ve
.SH "WHEN IN DOUBT"
.IX Header "WHEN IN DOUBT"
0MQ is a relatively large framework, and to use it you need to be comfortable
with a lot of concepts. If you think this module is not behaving like you
expect it to, \fIplease read the documents for the C \s-1API\s0\fR
.SH "ASYNCHRONOUS I/O WITH ZEROMQ"
.IX Header "ASYNCHRONOUS I/O WITH ZEROMQ"
By default 0MQ comes with its own \fBzmq_poll()\fR mechanism that can handle
non-blocking sockets. You can use this by calling zmq_poll with a list of
hashrefs:
.PP
.Vb 12
\&    zmq_poll([
\&        {
\&            fd => fileno(STDOUT),
\&            events => ZMQ_POLLOUT,
\&            callback => \e&callback,
\&        },
\&        {
\&            socket => $zmq_socket,
\&            events => ZMQ_POLLIN,
\&            callback => \e&callback
\&        },
\&    ], $timeout );
.Ve
.PP
Unfortunately this custom polling scheme doesn't play too well with AnyEvent.
.PP
Fortunately you can use getsockopt to retrieve the underlying file descriptor,
so use that to integrate ZMQ::LibZMQ4 and AnyEvent:
.PP
.Vb 8
\&    my $socket = zmq_socket( $ctxt, ZMQ_REP );
\&    my $fh = zmq_getsockopt( $socket, ZMQ_FD );
\&    my $w; $w = AE::io $fh, 0, sub {
\&        while ( my $msg = zmq_recv( $socket, ZMQ_RCVMORE ) ) {
\&            # do something with $msg;
\&        }
\&        undef $w;
\&    };
.Ve
.SH "NOTES ON MULTI-PROCESS and MULTI-THREADED USAGE"
.IX Header "NOTES ON MULTI-PROCESS and MULTI-THREADED USAGE"
0MQ works on both multi-process and multi-threaded use cases, but you need
to be careful about sharing ZMQ::LibZMQ4 objects.
.PP
For multi-process environments, you should not be sharing the context object.
Create separate contexts for each process, and therefore you shouldn't
be sharing the socket objects either.
.PP
For multi-thread environments, you can share the same context object. However
you cannot share sockets. Note that while the Perl Socket objects survive
between threads, their underlying C structures do not, and you will get an 
error if you try to use them between sockets.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
ZMQ::LibZMQ4 attempts to stick to the libzmq interface as much as possible. Unless there is a structural problem (say, an underlying pointer that the Perl binding expects was missing), no function should throw an exception.
.PP
Return values should resemble that of libzmq, except for when new data is allocated and returned to the user \- That includes things like \f(CW\*(C`zmq_init()\*(C'\fR, \f(CW\*(C`zmq_socket()\*(C'\fR, \f(CW\*(C`zmq_msg_data()\*(C'\fR, etc.
.PP
Where applicable, $! should be updated to match the value set by libzmq, so you should be able to do:
.PP
.Vb 4
\&    my $cxt = zmq_init();
\&    if (! $cxt) {
\&        die "zmq_init() failed with $!";
\&    }
.Ve
.ie n .SS "$errno = \fBzmq_errno()\fP"
.el .SS "\f(CW$errno\fP = \fBzmq_errno()\fP"
.IX Subsection "$errno = zmq_errno()"
Returns the value of errno variable for the calling thread. You normally should not need to use this function. See the man page for \fBzmq_errno()\fR provided by libzmq.
.ie n .SS "$string = zmq_strerror( $errno )"
.el .SS "\f(CW$string\fP = zmq_strerror( \f(CW$errno\fP )"
.IX Subsection "$string = zmq_strerror( $errno )"
Returns the string representation of \f(CW$errno\fR. Use this to stringify errors that libzmq provides.
.ie n .SS "$cxt = zmq_init( $threads )"
.el .SS "\f(CW$cxt\fP = zmq_init( \f(CW$threads\fP )"
.IX Subsection "$cxt = zmq_init( $threads )"
Creates a new context object. \f(CW$threads\fR argument is optional.
Context objects can be reused across threads.
.PP
Returns undef upon error, and sets $!.
.PP
Note: Deprecated in libzmq, but the Perl binding will silently fallback to
using \f(CW\*(C`zmq_ctx_new()\*(C'\fR, if available.
.ie n .SS "$cxt = zmq_ctx_new( $threads );"
.el .SS "\f(CW$cxt\fP = zmq_ctx_new( \f(CW$threads\fP );"
.IX Subsection "$cxt = zmq_ctx_new( $threads );"
Creates a new context object. \f(CW$threads\fR argument is optional.
Context objects can be reused across threads.
.PP
Returns undef upon error, and sets $!.
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_ctx_get( $cxt, $option )"
.el .SS "\f(CW$rv\fP = zmq_ctx_get( \f(CW$cxt\fP, \f(CW$option\fP )"
.IX Subsection "$rv = zmq_ctx_get( $cxt, $option )"
Gets the value for the given option.
.PP
Returns \-1 status upon failure, and sets $!
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_ctx_set( $cxt, $option, $value )"
.el .SS "\f(CW$rv\fP = zmq_ctx_set( \f(CW$cxt\fP, \f(CW$option\fP, \f(CW$value\fP )"
.IX Subsection "$rv = zmq_ctx_set( $cxt, $option, $value )"
Sets the value for the given option.
.PP
Returns a non-zero status upon failure, and sets $!.
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_term( $cxt )"
.el .SS "\f(CW$rv\fP = zmq_term( \f(CW$cxt\fP )"
.IX Subsection "$rv = zmq_term( $cxt )"
Terminates the context. Be careful, as it might hang if you have pending socket
operations.
.PP
Returns a non-zero status upon failure, and sets $!.
.PP
Note: Deprecated in libzmq, but the Perl binding will silently fallback to
using \f(CW\*(C`zmq_ctx_destroy()\*(C'\fR, if available.
.ie n .SS "$rv = zmq_ctx_destroy( $cxt )"
.el .SS "\f(CW$rv\fP = zmq_ctx_destroy( \f(CW$cxt\fP )"
.IX Subsection "$rv = zmq_ctx_destroy( $cxt )"
Terminates the context. Be careful, as it might hang if you have pending socket
operations.
.PP
Returns a non-zero status upon failure, and sets $!.
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$socket = zmq_socket( $cxt, $socket_type )"
.el .SS "\f(CW$socket\fP = zmq_socket( \f(CW$cxt\fP, \f(CW$socket_type\fP )"
.IX Subsection "$socket = zmq_socket( $cxt, $socket_type )"
Creates a new socket object. \f(CW$socket_types\fR are constants declared in ZMQ::Constants. Sockets cannot be reused across threads.
.PP
Returns undef upon error, and sets $!.
.ie n .SS "$rv = zmq_bind( $sock, $address )"
.el .SS "\f(CW$rv\fP = zmq_bind( \f(CW$sock\fP, \f(CW$address\fP )"
.IX Subsection "$rv = zmq_bind( $sock, $address )"
Binds the socket to listen to specified \f(CW$address\fR.
.PP
Returns a non-zero status upon failure, and sets $!
.ie n .SS "$rv = zmq_unbind( $sock, $address )"
.el .SS "\f(CW$rv\fP = zmq_unbind( \f(CW$sock\fP, \f(CW$address\fP )"
.IX Subsection "$rv = zmq_unbind( $sock, $address )"
Stops listening on this endpoint.
.PP
Returns a non-zero status upon failure, and sets $!
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_connect( $sock, $address )"
.el .SS "\f(CW$rv\fP = zmq_connect( \f(CW$sock\fP, \f(CW$address\fP )"
.IX Subsection "$rv = zmq_connect( $sock, $address )"
Connects the socket to the specified \f(CW$address\fR.
.PP
Returns a non-zero status upon failure, and sets $!
.ie n .SS "$rv = zmq_disconnect( $sock, $address )"
.el .SS "\f(CW$rv\fP = zmq_disconnect( \f(CW$sock\fP, \f(CW$address\fP )"
.IX Subsection "$rv = zmq_disconnect( $sock, $address )"
Disconnects the socket from the specified \f(CW$address\fR.
.PP
Returns a non-zero status upon failure, and sets $!
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_close( $sock )"
.el .SS "\f(CW$rv\fP = zmq_close( \f(CW$sock\fP )"
.IX Subsection "$rv = zmq_close( $sock )"
Closes the socket explicitly.
.PP
Returns a non-zero status upon failure, and sets $!.
.ie n .SS "$value = zmq_getsockopt( $socket, $option )"
.el .SS "\f(CW$value\fP = zmq_getsockopt( \f(CW$socket\fP, \f(CW$option\fP )"
.IX Subsection "$value = zmq_getsockopt( $socket, $option )"
Gets the value of the specified option.
.PP
If the particular version of ZMQ::LibZMQ4 does not implement the named socket option, an exception will be thrown:
.PP
.Vb 2
\&    /* barfs, because we don\*(Aqt know what type this new option is */
\&    zmq_getsockopt( $socket, ZMQ_NEW_SHINY_OPTION );
.Ve
.PP
In this case you can either use ZMQ::Constants, or you can use one of the utility functions that ZMQ::LibZMQ4 provides.
.IP "Using ZMQ::Constants" 4
.IX Item "Using ZMQ::Constants"
ZMQ::LibZMQ4 internally refers to ZMQ::Constants to learn about the type of a
socket option. You can easily add new constants to this map:
.Sp
.Vb 2
\&    use ZMQ::Constants;
\&    ZMQ::Constants::add_sockopt_type( "int" => ZMQ_NEW_SHINY_OPTION );
\&
\&    # Then elsewhere...
\&    my $value = zmq_getsockopt( $socket, ZMQ_NEW_SHINY_OPTION );
.Ve
.IP "Using utilities in ZMQ::LibZMQ4" 4
.IX Item "Using utilities in ZMQ::LibZMQ4"
.Vb 6
\&    /* say you know that the value is an int, int64, uint64, or char *
\&       by reading the zmq docs */
\&    $int    = zmq_getsockopt_int( $socket, ZMQ_NEW_SHINY_OPTION );
\&    $int64  = zmq_getsockopt_int64( $socket, ZMQ_NEW_SHINY_OPTION );
\&    $uint64 = zmq_getsockopt_uint64( $socket, ZMQ_NEW_SHINY_OPTION );
\&    $string = zmq_getsockopt_string( $socket, ZMQ_NEW_SHINY_OPTION );
.Ve
.ie n .SS "$status = zmq_setsockopt( $socket, $option, $value )"
.el .SS "\f(CW$status\fP = zmq_setsockopt( \f(CW$socket\fP, \f(CW$option\fP, \f(CW$value\fP )"
.IX Subsection "$status = zmq_setsockopt( $socket, $option, $value )"
Sets the value of the specified option. Returns the status.
.PP
See \f(CW\*(C`zmq_getsockopt()\*(C'\fR if you have problems with ZMQ::LibZMQ4 not knowing the type of the option.
.ie n .SS "$bytes = zmq_send($sock, $buffer, $size, $flags)"
.el .SS "\f(CW$bytes\fP = zmq_send($sock, \f(CW$buffer\fP, \f(CW$size\fP, \f(CW$flags\fP)"
.IX Subsection "$bytes = zmq_send($sock, $buffer, $size, $flags)"
Queues \f(CW$size\fR bytes from \f(CW$buffer\fR to be sent from the socket. Argument \f(CW$flags\fR may be omitted. If \f(CW$size\fR is \-1, then the size of the buffer calculated via \f(CW\*(C`SvPV()\*(C'\fR will be used.
.PP
Returns the number of bytes sent on success (which should be exact \f(CW$size\fR)
.PP
Returns \-1 upon failure, and sets $!.
.ie n .SS "$rv = zmq_sendmsg($sock, $message, $flags)"
.el .SS "\f(CW$rv\fP = zmq_sendmsg($sock, \f(CW$message\fP, \f(CW$flags\fP)"
.IX Subsection "$rv = zmq_sendmsg($sock, $message, $flags)"
Queues \f(CW$message\fR to be sent via \f(CW$sock\fR. Argument \f(CW$flags\fR may be omitted.
.PP
If \f(CW$message\fR is a non-ref, creates a new ZMQ::LibZMQ4::Message object via \f(CW\*(C`zmq_msg_init_data()\*(C'\fR, and uses that to pass to the underlying C layer..
.PP
Returns the number of bytes sent on success (which should be exact \f(CW$size\fR)
.PP
Returns \-1 upon failure, and sets $!.
.PP
Note: Deprecated in favor of \f(CW\*(C`zmq_msg_send()\*(C'\fR, and may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_msg_send($message, $sock, $flags)"
.el .SS "\f(CW$rv\fP = zmq_msg_send($message, \f(CW$sock\fP, \f(CW$flags\fP)"
.IX Subsection "$rv = zmq_msg_send($message, $sock, $flags)"
Queues \f(CW$message\fR to be sent via \f(CW$sock\fR. Argument \f(CW$flags\fR may be omitted.
.PP
If \f(CW$message\fR is a non-ref, creates a new ZMQ::LibZMQ4::Message object via \f(CW\*(C`zmq_msg_init_data()\*(C'\fR, and uses that to pass to the underlying C layer..
.PP
Returns the number of bytes sent on success (which should be exact \f(CW$size\fR)
.PP
Returns \-1 upon failure, and sets $!.
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_recv($sock, $buffer, $len, $flags)"
.el .SS "\f(CW$rv\fP = zmq_recv($sock, \f(CW$buffer\fP, \f(CW$len\fP, \f(CW$flags\fP)"
.IX Subsection "$rv = zmq_recv($sock, $buffer, $len, $flags)"
Receives a new message from \f(CW$sock\fR, and store the message payload in \f(CW$buffer\fR, up to \f(CW$len\fR bytes. Argument \f(CW$flags\fR may be omitted.
.PP
Returns the number of bytes in the \fIoriginal\fR message, which may exceed \f(CW$len\fR (if you have \f(CW$rv\fR > \f(CW$len\fR, then the message was truncated).
.PP
Returns \-1 upon failure, and sets $!.
.ie n .SS "$message = zmq_recvmsg($sock, $flags)"
.el .SS "\f(CW$message\fP = zmq_recvmsg($sock, \f(CW$flags\fP)"
.IX Subsection "$message = zmq_recvmsg($sock, $flags)"
Receives a new message from \f(CW$sock\fR. Argument \f(CW$flags\fR may be omitted.
Returns the message object.
.PP
Returns undef upon failure, and sets $!.
.PP
Note: Although this function is marked as deprecated in libzmq3, it will
stay in the Perl binding as the official short-circuit version of
\&\f(CW\*(C`zmq_msg_recv()\*(C'\fR, so that you don't have to create a message object
every time.
.ie n .SS "$rv = zmq_msg_recv($msg, $sock, $flags)"
.el .SS "\f(CW$rv\fP = zmq_msg_recv($msg, \f(CW$sock\fP, \f(CW$flags\fP)"
.IX Subsection "$rv = zmq_msg_recv($msg, $sock, $flags)"
Receives a new message from \f(CW$sock\fR, and writes the new content to \f(CW$msg\fR.
Argument \f(CW$flags\fR may be omitted.
.PP
Returns the number of bytes in the message if successful.
.PP
Returns \-1 upon failure, and sets $!.
.PP
Other than the fact that libzmq has deprecated \f(CW\*(C`zmq_recvmsg()\*(C'\fR, this
construct is useful if you don't want to allocate a message struct for
every recv call:
.PP
.Vb 5
\&    my $msg = zmq_msg_init();
\&    while (1) {
\&        my $rv = zmq_msg_recv($msg, $sock, $flags);
\&        ...
\&    }
.Ve
.PP
Note: may not be available depending on your libzmq version
.ie n .SS "$msg = \fBzmq_msg_init()\fP"
.el .SS "\f(CW$msg\fP = \fBzmq_msg_init()\fP"
.IX Subsection "$msg = zmq_msg_init()"
Creates a new message object.
.PP
Returns undef upon failure, and sets $!.
.ie n .SS "$msg = zmq_msg_init_data($string)"
.el .SS "\f(CW$msg\fP = zmq_msg_init_data($string)"
.IX Subsection "$msg = zmq_msg_init_data($string)"
Creates a new message object, and sets the message payload to the string in \f(CW$string\fR.
.PP
Returns undef upon failure, and sets $!.
.ie n .SS "$msg = zmq_msg_init_size($size)"
.el .SS "\f(CW$msg\fP = zmq_msg_init_size($size)"
.IX Subsection "$msg = zmq_msg_init_size($size)"
Creates a new message object, allocating \f(CW$size\fR bytes. This call isn't so useful from within Perl
.PP
Returns undef upon failure, and sets $!.
.ie n .SS "$string = zmq_msg_data( $msg )"
.el .SS "\f(CW$string\fP = zmq_msg_data( \f(CW$msg\fP )"
.IX Subsection "$string = zmq_msg_data( $msg )"
Returns the payload contained in \f(CW$msg\fR
.ie n .SS "$size = zmq_msg_size( $msg )"
.el .SS "\f(CW$size\fP = zmq_msg_size( \f(CW$msg\fP )"
.IX Subsection "$size = zmq_msg_size( $msg )"
Returns the size of payload contained in \f(CW$msg\fR
.ie n .SS "zmq_msg_copy( $dst, $src )"
.el .SS "zmq_msg_copy( \f(CW$dst\fP, \f(CW$src\fP )"
.IX Subsection "zmq_msg_copy( $dst, $src )"
Copies contents of \f(CW$src\fR to \f(CW$dst\fR.
.PP
Returns a non-zero status upon failure, and sets $!.
.ie n .SS "zmq_msg_move( $dst, $src )"
.el .SS "zmq_msg_move( \f(CW$dst\fP, \f(CW$src\fP )"
.IX Subsection "zmq_msg_move( $dst, $src )"
Moves contents of \f(CW$src\fR to \f(CW$dst\fR
.PP
Returns a non-zero status upon failure, and sets $!.
.ie n .SS "$rv = zmq_msg_close( $msg )"
.el .SS "\f(CW$rv\fP = zmq_msg_close( \f(CW$msg\fP )"
.IX Subsection "$rv = zmq_msg_close( $msg )"
Closes, cleans up the message.
.PP
Returns a non-zero status upon failure, and sets $!.
.ie n .SS "$rv = zmq_poll( \e@pollitems, $timeout )"
.el .SS "\f(CW$rv\fP = zmq_poll( \e@pollitems, \f(CW$timeout\fP )"
.IX Subsection "$rv = zmq_poll( @pollitems, $timeout )"
\&\f(CW@pollitems\fR are list of hash references containing the following elements:
.IP "fd or socket" 4
.IX Item "fd or socket"
One of either \f(CW\*(C`fd\*(C'\fR or \f(CW\*(C`socket\*(C'\fR key must exist. \f(CW\*(C`fd\*(C'\fR should contain a \s-1UNIX\s0 file descriptor. \f(CW\*(C`socket\*(C'\fR should contain a \f(CW\*(C`ZMQ::LibZMQ4::Socket\*(C'\fR socket object.
.IP "events" 4
.IX Item "events"
A bit mask containing \f(CW\*(C`ZMQ_POLLOUT\*(C'\fR, \f(CW\*(C`ZMQ_POLLIN\*(C'\fR, \f(CW\*(C`ZMQ_POLLERR\*(C'\fR or combination there of.
.IP "callback" 4
.IX Item "callback"
A subroutine reference, which will be called without arguments when the socket or descriptor is available.
.PP
In scalar context, returns the return value of \fBzmq_poll()\fR in the C layer, and sets $!.
.PP
.Vb 4
\&    my $rv = zmq_poll( .... ); # do scalar(zmq_poll(...)) if you\*(Aqre nuerotic
\&    if ( $rv == \-1 ) {
\&        warn "zmq_poll failed: $!";
\&    }
.Ve
.PP
In list context, return a list containing as many booleans as there are 
elements in \f(CW@pollitems\fR.
These booleans indicate whether the socket in question has fired the callback.
.PP
.Vb 9
\&    my @pollitems = (...);
\&    my @fired     = zmq_poll( @pollitems ... );
\&    for my $i ( 0 .. $#pollitems ) {
\&        my $fired = $fired[$i];
\&        if ( $fired ) {
\&            my $item = $pollitems[$i];
\&            ...
\&        }
\&    }
.Ve
.SS "\fBzmq_version()\fP"
.IX Subsection "zmq_version()"
Returns the version of the underlying zeromq library that is being linked.
In scalar context, returns a dotted version string. In list context,
returns a 3\-element list of the version numbers:
.PP
.Vb 2
\&    my $version_string = ZMQ::LibZMQ4::zmq_version();
\&    my ($major, $minor, $patch) = ZMQ::LibZMQ4::zmq_version();
.Ve
.ie n .SS "zmq_device($type, $sock1, $sock2)"
.el .SS "zmq_device($type, \f(CW$sock1\fP, \f(CW$sock2\fP)"
.IX Subsection "zmq_device($type, $sock1, $sock2)"
Creates a new \*(L"device\*(R". See \f(CW\*(C`zmq_device\*(C'\fR for details. \fBzmq_device()\fR will only return if/when the current context is closed. Therefore, the return value is always \-1, and $! is always \s-1ETERM\s0
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "zmq_proxy($frontend_sock, $backend_sock, $capture_sock)"
.el .SS "zmq_proxy($frontend_sock, \f(CW$backend_sock\fP, \f(CW$capture_sock\fP)"
.IX Subsection "zmq_proxy($frontend_sock, $backend_sock, $capture_sock)"
\&\s-1WARNING: EXPERIMENTAL.\s0 Use at your own risk.
.PP
Start a proxy in the current thread, which connects the frontend socket to a
backend socket. The capture sock is optional, and is by default undef.
.PP
Note: may not be available depending on your libzmq version.
.ie n .SS "$rv = zmq_socket_monitor($socket, $addr, events)"
.el .SS "\f(CW$rv\fP = zmq_socket_monitor($socket, \f(CW$addr\fP, events)"
.IX Subsection "$rv = zmq_socket_monitor($socket, $addr, events)"
Note: may not be available depending on your libzmq version.
.SH "FUNCTIONS PROVIDED BY ZMQ::LIBZMQ4"
.IX Header "FUNCTIONS PROVIDED BY ZMQ::LIBZMQ4"
These functions are provided by ZMQ::LibZMQ4 to make some operations easier in the Perl binding. They are not part of the official libzmq interface.
.ie n .SS "$value = zmq_getsockopt_int( $sock, $option )"
.el .SS "\f(CW$value\fP = zmq_getsockopt_int( \f(CW$sock\fP, \f(CW$option\fP )"
.IX Subsection "$value = zmq_getsockopt_int( $sock, $option )"
.ie n .SS "$value = zmq_getsockopt_int64( $sock, $option )"
.el .SS "\f(CW$value\fP = zmq_getsockopt_int64( \f(CW$sock\fP, \f(CW$option\fP )"
.IX Subsection "$value = zmq_getsockopt_int64( $sock, $option )"
.ie n .SS "$value = zmq_getsockopt_string( $sock, $option )"
.el .SS "\f(CW$value\fP = zmq_getsockopt_string( \f(CW$sock\fP, \f(CW$option\fP )"
.IX Subsection "$value = zmq_getsockopt_string( $sock, $option )"
.ie n .SS "$value = zmq_getsockopt_uint64( $sock, $option )"
.el .SS "\f(CW$value\fP = zmq_getsockopt_uint64( \f(CW$sock\fP, \f(CW$option\fP )"
.IX Subsection "$value = zmq_getsockopt_uint64( $sock, $option )"
.ie n .SS "$rv = zmq_setsockopt_int( $sock, $option, $value );"
.el .SS "\f(CW$rv\fP = zmq_setsockopt_int( \f(CW$sock\fP, \f(CW$option\fP, \f(CW$value\fP );"
.IX Subsection "$rv = zmq_setsockopt_int( $sock, $option, $value );"
.ie n .SS "$rv = zmq_setsockopt_int64( $sock, $option, $value );"
.el .SS "\f(CW$rv\fP = zmq_setsockopt_int64( \f(CW$sock\fP, \f(CW$option\fP, \f(CW$value\fP );"
.IX Subsection "$rv = zmq_setsockopt_int64( $sock, $option, $value );"
.ie n .SS "$rv = zmq_setsockopt_string( $sock, $option, $value );"
.el .SS "\f(CW$rv\fP = zmq_setsockopt_string( \f(CW$sock\fP, \f(CW$option\fP, \f(CW$value\fP );"
.IX Subsection "$rv = zmq_setsockopt_string( $sock, $option, $value );"
.ie n .SS "$rv = zmq_setsockopt_uint64( $sock, $option, $value );"
.el .SS "\f(CW$rv\fP = zmq_setsockopt_uint64( \f(CW$sock\fP, \f(CW$option\fP, \f(CW$value\fP );"
.IX Subsection "$rv = zmq_setsockopt_uint64( $sock, $option, $value );"
.SH "DEBUGGING XS"
.IX Header "DEBUGGING XS"
If you see segmentation faults, and such, you need to figure out where the error is occurring in order for the maintainers to figure out what happened. Here's a very very brief explanation of steps involved.
.PP
First, make sure to compile \f(CW\*(C`ZMQ::LibZMQ4\*(C'\fR with debugging on by specifying \-g:
.PP
.Vb 2
\&    perl Makefile.PL \-g
\&    make
.Ve
.PP
Then fire gdb:
.PP
.Vb 2
\&    gdb perl
\&    (gdb) R \-Mblib /path/to/your/script.pl
.Ve
.PP
When you see the crash, get a backtrace:
.PP
.Vb 1
\&    (gdb) bt
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
This is an early release. Proceed with caution, please report
(or better yet: fix) bugs you encounter.
.PP
This module has been tested against \fBzeromq 3.2.2\fR. Semantics of this
module rely heavily on the underlying zeromq version. Make sure
you know which version of zeromq you're working with.
.PP
As of 1.04 some new constants have been added, but they are not really
meant to be used by consumers of this module. If you find yourself
looking at these, please let us know why you need to use it \*(-- we'll see
if we can find a workaround, or make these constants public.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://zeromq.org>
.PP
<http://github.com/mosconi/p5\-ZMQ>
.PP
<http://github.com/lestrrat/p5\-ZMQ>
.PP
ZMQ::Constants
.PP
ZMQ::LibZMQ3
.PP
ZMQ::LibZMQ2
.SH "AUTHOR"
.IX Header "AUTHOR"
Rodrigo Mosconi \f(CW\*(C`<perl@mosconi.mat.br>\*(C'\fR
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
The ZMQ::LibZMQ4 module is
.PP
Copyright (C) 2014 by Rodrigo Mosconi
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.0 or,
at your option, any later version of Perl 5 you may have available.
